<!DOCTYPE html>
<html>
    <head>
        <title>Eternal Darkness Spells</title>
        <style>
            :root {
                --background-color: White;
                --color: Black;
                --chatturgha-color: Maroon;
                --ulyaoth-color: MediumBlue;
                --xellotath-color: DarkGreen;
                --mantorok-color: DarkMagenta;
                --unaligned-color: SaddleBrown;
                --inactive-color: Silver;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --background-color: Black;
                    --color: White;
                    --chatturgha-color: Tomato;
                    --ulyaoth-color: DeepSkyBlue;
                    --xellotath-color: SpringGreen;
                    --mantorok-color: Violet;
                    --unaligned-color: Khaki;
                    --inactive-color: DimGray;
                }
            }
            body {
                background-color: var(--background-color);
                color: var(--color);
                padding: 1rem;
            }
            button { margin: .5rem 0; }
            .translation { display: none; }
            .translation.show { display: inline; }
            .translation::before { content: '\00a0'; }
            #chatturgha, .chatturgha .table-data.selected { color: var(--chatturgha-color); }
            #ulyaoth, .ulyaoth .table-data.selected { color: var(--ulyaoth-color); }
            #xellotath, .xellotath .table-data.selected { color: var(--xellotath-color); }
            #mantorok, .mantorok .table-data.selected { color: var(--mantorok-color); }
            .unaligned .table-data.selected { color: var(--unaligned-color); }
            .table-data.inactive { color: var(--inactive-color) !important; }
            .table, .table-cell { border: 1px solid var(--color); }
            .table-group {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
            }
            .table-cell {
                margin: .063rem;
                padding: .5rem;
                display: flex;
                flex-wrap: wrap;
                align-content: center;
                justify-content: center;
            }
            .table-heading { grid-column: 1/-1; }
            .table-data { cursor: pointer; }
            @media (min-width: 666px) {
                .table { display: flex; }
                .table-group {
                    grid-template-columns: 1fr;
                    flex: 1;
                }
                .table-group.alignment { grid-template-rows: auto repeat(4, 1fr); }
                .table-group.verb, .table-group.noun { grid-template-rows: auto repeat(5, 1fr); }
                .table-group.spell { grid-template-rows: auto repeat(10, 1fr); }
            }
        </style>
    </head>
    <body>
        <h1>Runes and Spells</h1>
        <button id="translate">Show translations</button>
        <button id="reset">Reset</button>
        <div class="unaligned" id="alignment">
            <div class="table">
                <div class="table-group alignment">
                    <div class="table-cell table-heading">Alignment</div>
                    <div class="table-cell table-data" id="chatturgha" data-type="alignment">Chattur'gha<span class="translation">(Claw)</span></div>
                    <div class="table-cell table-data" id="ulyaoth" data-type="alignment">Ulyaoth<span class="translation">(Veil)</span></div>
                    <div class="table-cell table-data" id="xellotath" data-type="alignment">Xel'lotath<span class="translation">(Sigil)</span></div>
                    <div class="table-cell table-data" id="mantorok" data-type="alignment">Mantorok<span class="translation">(Black Heart)</span></div>
                </div>
                <div class="table-group verb">
                    <div class="table-cell table-heading">Verb</div>
                    <div class="table-cell table-data" id="bankorok" data-type="verb">Bankorok<span class="translation">(Protect)</span></div>
                    <div class="table-cell table-data" id="tier" data-type="verb">Tier<span class="translation">(Summon)</span></div>
                    <div class="table-cell table-data" id="narokath" data-type="verb">Narokath<span class="translation">(Absorb)</span></div>
                    <div class="table-cell table-data" id="nethlek" data-type="verb">Nethlek<span class="translation">(Dispel)</span></div>
                    <div class="table-cell table-data" id="antorbok" data-type="verb">Antorbok<span class="translation">(Project)</span></div>
                </div>
                <div class="table-group noun">
                    <div class="table-cell table-heading">Noun</div>
                    <div class="table-cell table-data" id="magormor" data-type="noun">Magormor<span class="translation">(Item)</span></div>
                    <div class="table-cell table-data" id="redgormor" data-type="noun">Redgormor<span class="translation">(Area)</span></div>
                    <div class="table-cell table-data" id="aretak" data-type="noun">Aretak<span class="translation">(Creature)</span></div>
                    <div class="table-cell table-data" id="santak" data-type="noun">Santak<span class="translation">(Self)</span></div>
                    <div class="table-cell table-data" id="pargon" data-type="noun">Pargon<span class="translation">(Power)</span></div>
                </div>
                <div class="table-group spell">
                    <div class="table-cell table-heading">Spell</div>
                    <div class="table-cell table-data" id="enchant" data-type="spell">Enchant Item</div>
                    <div class="table-cell table-data" id="recover" data-type="spell">Recover</div>
                    <div class="table-cell table-data" id="reveal" data-type="spell">Reveal Invisible</div>
                    <div class="table-cell table-data" id="field" data-type="spell">Damage Field</div>
                    <div class="table-cell table-data" id="dispel" data-type="spell">Dispel Magick</div>
                    <div class="table-cell table-data" id="summon" data-type="spell">Summon Creature</div>
                    <div class="table-cell table-data" id="shield" data-type="spell">Shield</div>
                    <div class="table-cell table-data" id="attack" data-type="spell">Magickal Attack</div>
                    <div class="table-cell table-data" id="pool" data-type="spell">Magick Pool</div>
                    <div class="table-cell table-data" id="bind" data-type="spell">Bind</div>
                </div>
            </div>
        </div>
        <script>
            const spellDict = { /* this should be doable with this dictionary only and not the matrix as well */
                'enchant': ['antorbok', 'magormor'],
                'recover': ['narokath', 'santak'],
                'reveal': ['narokath', 'redgormor'],
                'field': ['bankorok', 'redgormor'],
                'dispel': ['nethlek', 'redgormor'],
                'summon': ['tier', 'aretak'],
                'shield': ['bankorok', 'santak'],
                'attack': ['antorbok', 'redgormor'],
                'pool': ['tier', 'redgormor'],
                'bind': ['bankorok', 'aretak']
            };
            const spellMatrix = [
                ['enchant', 'antorbok', 'magormor', 'pargon', 'chatturgha'],
                ['recover', 'narokath', 'santak', 'pargon', 'chatturgha'],
                ['reveal', 'narokath', 'redgormor', 'pargon', 'chatturgha'],
                ['field', 'bankorok', 'redgormor', 'pargon', 'chatturgha'],
                ['dispel', 'nethlek', 'redgormor', 'pargon', 'chatturgha'],
                ['summon', 'tier', 'aretak', 'pargon', 'chatturgha'],
                ['shield', 'bankorok', 'santak', 'pargon', 'chatturgha'],
                ['attack', 'antorbok', 'redgormor', 'pargon', 'chatturgha'],
                ['pool', 'tier', 'redgormor', 'pargon', 'chatturgha'],
                ['bind', 'bankorok', 'aretak', 'pargon', 'chatturgha'],
                ['enchant', 'antorbok', 'magormor', 'pargon', 'ulyaoth'],
                ['recover', 'narokath', 'santak', 'pargon', 'ulyaoth'],
                ['reveal', 'narokath', 'redgormor', 'pargon', 'ulyaoth'],
                ['field', 'bankorok', 'redgormor', 'pargon', 'ulyaoth'],
                ['dispel', 'nethlek', 'redgormor', 'pargon', 'ulyaoth'],
                ['summon', 'tier', 'aretak', 'pargon', 'ulyaoth'],
                ['shield', 'bankorok', 'santak', 'pargon', 'ulyaoth'],
                ['attack', 'antorbok', 'redgormor', 'pargon', 'ulyaoth'],
                ['pool', 'tier', 'redgormor', 'pargon', 'ulyaoth'],
                ['bind', 'bankorok', 'aretak', 'pargon', 'ulyaoth'],
                ['enchant', 'antorbok', 'magormor', 'pargon', 'xellotath'],
                ['recover', 'narokath', 'santak', 'pargon', 'xellotath'],
                ['reveal', 'narokath', 'redgormor', 'pargon', 'xellotath'],
                ['field', 'bankorok', 'redgormor', 'pargon', 'xellotath'],
                ['dispel', 'nethlek', 'redgormor', 'pargon', 'xellotath'],
                ['summon', 'tier', 'aretak', 'pargon', 'xellotath'],
                ['shield', 'bankorok', 'santak', 'pargon', 'xellotath'],
                ['attack', 'antorbok', 'redgormor', 'pargon', 'xellotath'],
                ['pool', 'tier', 'redgormor', 'pargon', 'xellotath'],
                ['bind', 'bankorok', 'aretak', 'pargon', 'xellotath'],
                ['enchant', 'antorbok', 'magormor', 'pargon', 'mantorok'],
                ['recover', 'narokath', 'santak', 'pargon', 'mantorok'],
                ['reveal', 'narokath', 'redgormor', 'pargon', 'mantorok'],
                ['field', 'bankorok', 'redgormor', 'pargon', 'mantorok'],
                ['dispel', 'nethlek', 'redgormor', 'pargon', 'mantorok'],
                ['shield', 'bankorok', 'santak', 'pargon', 'mantorok'],
                ['attack', 'antorbok', 'redgormor', 'pargon', 'mantorok'],
                ['pool', 'tier', 'redgormor', 'pargon', 'mantorok'],
                ['bind', 'bankorok', 'aretak', 'pargon', 'mantorok']
            ];
            const runes = document.getElementsByClassName('table-data');
            const translations = document.getElementsByClassName('translation');
            document.getElementById('translate').addEventListener('click', toggleTranslations);
            document.getElementById('reset').addEventListener('click', resetTable);
            Array.from(runes).forEach(rune => {
                rune.addEventListener('click', function(e) {
                    /* don't disable or enable anything as pargon is compatible with all other nouns */
                    if (this.id === 'pargon') {
                        this.classList.toggle('selected');
                    }
                    else if (this.classList.toggle('selected')) {
                        /* remove selected from any other runes of same type */
                        Array.from(runes).forEach(rune => {
                            if (rune.dataset.type === this.dataset.type && !rune.isSameNode(this) && rune.id !== 'pargon') { /* pargon is always enabled */
                                rune.classList.remove('selected');
                            }
                        });
                        /* set alignment on table for color coding */
                        if (this.dataset.type === 'alignment') {
                            document.getElementById('alignment').className = this.id;
                        }
                        /* if a spell is selected also select corresponding runes */
                        else if (this.dataset.type === 'spell') {
                            Array.from(document.getElementsByClassName('selected')).forEach(rune => {
                                if (!rune.isSameNode(this) && rune.dataset.type !== 'alignment' && rune.id !== 'pargon') { /* pargon can always be selected */
                                    rune.classList.remove('selected');
                                }
                            });
                            let verb = document.getElementById(spellDict[this.id][0]);
                            let noun = document.getElementById(spellDict[this.id][1]);
                            verb.classList.add('selected');
                            noun.classList.add('selected');
                            /* special mantorok case */
                            if (document.getElementById('alignment').className === 'mantorok' && this.id === 'summon') {
                                document.getElementById('alignment').className = 'unaligned'; /* maybe this should reset alignment completely? */
                            }
                        }
                    }
                    else {
                        /* reset alignment color coding */
                        if (this.dataset.type === 'alignment') {
                            document.getElementById('alignment').className = 'unaligned';
                        }
                        else if (this.dataset.type === 'spell') {
                            Array.from(runes).forEach(rune => {
                                if (rune.dataset.type !== 'alignment') {
                                    rune.classList.remove('inactive', 'selected');
                                }
                            });
                        }
                    }
                    determineSpell();
                    toggleInactive(document.getElementById('alignment').className !== 'unaligned');
                });
            });

            function toggleInactive(aligned) {
                let selectedRunes = [];
                Array.from(document.getElementsByClassName('selected')).forEach(rune => {
                    selectedRunes.push(rune.id);
                });
                let possibleSpells = [];
                let activeRunes = [];
                spellMatrix.forEach(spell => {
                    if (selectedRunes.every(rune => spell.includes(rune))) {
                        possibleSpells.push(spell);
                    }
                });
                activeRunes = union(...possibleSpells);
                Array.from(runes).forEach(rune => {
                    rune.classList.remove('inactive');
                    if ((!activeRunes.includes(rune.id) || (aligned && rune.dataset.type === 'alignment')) && !rune.classList.contains('selected')) { /* special case for alignment they are common to all spells */
                        rune.classList.add('inactive');
                    }
                });
            }

            function determineSpell() {
                Array.from(document.querySelectorAll("[data-type='spell']")).forEach(spell => {
                    spell.classList.remove('selected');
                });
                verb = document.querySelector("[data-type='verb'].selected");
                noun = document.querySelector("[data-type='noun'].selected"); /* this is ok as pargon comes after all other nouns */
                if (verb && noun && noun.id !== 'pargon') { /* ignore pargon since it has no semantical meaning */
                    for (let [key, value] of Object.entries(spellDict)) {
                        if ([verb.id, noun.id].every(rune => value.includes(rune))) {
                            if (!(document.getElementById('alignment').className === 'mantorok' && key === 'summon')) { /* special mantorok case */
                                document.getElementById(key).classList.add('selected');
                            }
                        }
                    }
                }
            }

            function toggleTranslations() {
                Array.from(translations).forEach(t => {
                    t.classList.toggle('show');
                });
                this.innerHTML = (this.innerHTML === 'Show translations') ? 'Hide translations' : 'Show translations';
            }
            
            function resetTable(e, resetAlignment = true) {
                Array.from(runes).forEach(rune => {
                    if (!(rune.dataset.type === 'alignment' && !resetAlignment)) {
                        rune.className = 'table-cell table-data';
                    }
                });
            }
            
            function union() {
                let flat = [].concat(...arguments);
                return [...new Set(flat)];
            }
        </script>
    </body>
</html>
